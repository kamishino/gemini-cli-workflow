/**
 * lib/workflow-chain.js — Workflow Chaining System
 *
 * Carries context between workflows via .memory/session.md
 * When /brainstorm completes, it writes session context.
 * When /develop starts, it reads session context to pre-fill Phase 1.
 */

const fs = require("fs-extra");
const path = require("path");

const SESSION_FILE = ".memory/session.md";

/**
 * Write a session handoff for the next workflow.
 *
 * @param {string} projectDir
 * @param {object} session
 * @param {string} session.fromWorkflow - e.g. "/brainstorm"
 * @param {string} session.toWorkflow - e.g. "/develop"
 * @param {string} session.summary - What was decided
 * @param {string} session.selectedIdea - The chosen idea (if from brainstorm)
 * @param {object} session.context - Any additional context to pass
 */
async function writeSession(projectDir, session) {
  const sessionPath = path.join(projectDir, SESSION_FILE);
  await fs.ensureDir(path.dirname(sessionPath));

  const timestamp = new Date().toISOString();
  const content = `# Workflow Session Handoff

> Auto-generated by ${session.fromWorkflow} at ${timestamp}

## Source
- **From:** ${session.fromWorkflow}
- **To:** ${session.toWorkflow}
- **Created:** ${timestamp}

## Decision
${session.summary}

${session.selectedIdea ? `## Selected Idea\n${session.selectedIdea}\n` : ""}
${session.context ? `## Additional Context\n${JSON.stringify(session.context, null, 2)}\n` : ""}
## Instructions for Next Workflow
Skip clarification questions — context is already established above.
Proceed directly to planning/execution phase using the decision above.
`;

  await fs.writeFile(sessionPath, content, "utf8");
  return sessionPath;
}

/**
 * Read session handoff from a previous workflow.
 * Returns null if no session exists.
 */
async function readSession(projectDir) {
  const sessionPath = path.join(projectDir, SESSION_FILE);
  if (!(await fs.pathExists(sessionPath))) return null;

  const content = await fs.readFile(sessionPath, "utf8");

  // Parse basic fields
  const fromMatch = content.match(/\*\*From:\*\* (.+)/);
  const toMatch = content.match(/\*\*To:\*\* (.+)/);
  const decisionMatch = content.match(/## Decision\n([\s\S]*?)(?=\n##|$)/);

  return {
    raw: content,
    from: fromMatch ? fromMatch[1].trim() : null,
    to: toMatch ? toMatch[1].trim() : null,
    decision: decisionMatch ? decisionMatch[1].trim() : null,
  };
}

/**
 * Clear the session file after it has been consumed.
 */
async function clearSession(projectDir) {
  const sessionPath = path.join(projectDir, SESSION_FILE);
  if (await fs.pathExists(sessionPath)) {
    await fs.remove(sessionPath);
  }
}

/**
 * Check if a session handoff exists and is targeted at a specific workflow.
 */
async function hasSessionFor(projectDir, targetWorkflow) {
  const session = await readSession(projectDir);
  if (!session) return false;
  return session.to === targetWorkflow;
}

module.exports = {
  writeSession,
  readSession,
  clearSession,
  hasSessionFor,
};
